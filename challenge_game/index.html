<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>MileChamp</title>
    <style>
        :root {
            --bg-color: #050505;
            --accent-color: #00f3ff;
            --accent-glow: rgba(0, 243, 255, 0.6);
            --enemy-color: #ff0055;
            --enemy-glow: rgba(255, 0, 85, 0.4);
            --ui-font: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: var(--ui-font);
        }

        /* Scanline overlay for retro-modern feel */
        body::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(
                to bottom,
                rgba(255, 255, 255, 0),
                rgba(255, 255, 255, 0) 50%,
                rgba(0, 0, 0, 0.1) 50%,
                rgba(0, 0, 0, 0.1)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
        }

        /* NEW: Top Left Label */
        .top-left-info {
            position: absolute;
            top: 30px;
            left: 30px;
            text-align: left;
            pointer-events: none;
        }

        .top-left-info h3 {
            color: var(--accent-color);
            margin: 0;
            font-size: 1.1rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px var(--accent-glow);
            font-weight: 700;
            border-left: 3px solid var(--accent-color);
            padding-left: 10px;
        }

        .score-container {
            position: absolute;
            top: 40px;
            text-align: center;
            opacity: 0.8;
            transition: transform 0.1s;
        }

        #score-display {
            font-size: 4rem;
            font-weight: 800;
            color: white;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
            letter-spacing: -2px;
            margin: 0;
        }

        #score-label {
            font-size: 0.8rem;
            color: var(--accent-color);
            text-transform: uppercase;
            letter-spacing: 4px;
            margin-top: 5px;
            font-weight: 600;
        }

        /* Start / Game Over Screen */
        .modal {
            background: rgba(5, 5, 5, 0.85);
            backdrop-filter: blur(10px);
            padding: 40px 60px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            text-align: center;
            transform: translateY(0);
            transition: opacity 0.3s, transform 0.3s;
            pointer-events: auto;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
        }

        .modal.hidden {
            opacity: 0;
            transform: translateY(20px);
            pointer-events: none;
        }

        h1 {
            color: white;
            font-size: 3rem;
            margin: 0 0 10px 0;
            font-weight: 900;
            letter-spacing: -1px;
            background: linear-gradient(45deg, #fff, var(--accent-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        p {
            color: #aaa;
            font-size: 1rem;
            margin: 0 0 30px 0;
            line-height: 1.5;
        }

        .btn {
            background: transparent;
            color: var(--accent-color);
            border: 2px solid var(--accent-color);
            padding: 15px 40px;
            font-size: 1.2rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
            font-family: var(--ui-font);
        }

        .btn:hover {
            background: var(--accent-color);
            color: #000;
            box-shadow: 0 0 30px var(--accent-glow);
        }

        .instructions {
            margin-top: 20px;
            font-size: 0.8rem;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        /* Flash effect on impact */
        #flash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: white;
            opacity: 0;
            pointer-events: none;
            z-index: 30;
            transition: opacity 0.1s;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>
    <div id="flash"></div>

    <div id="ui-layer">
        
        <!-- NEW: Top Left Information -->
        <div class="top-left-info">
            <h3>Who will travel the<br>highest distance!</h3>
        </div>

        <div class="score-container" id="score-container">
            <h2 id="score-display">0</h2>
            <div id="score-label">Distance</div>
        </div>

        <div id="start-screen" class="modal">
            <h1>PHASE SHIFT</h1>
            <p>Procedural Obstacle Evasion</p>
            <button class="btn" id="start-btn">Initialize</button>
            <div class="instructions">Click or Space to Invert Gravity</div>
        </div>

        <div id="gameover-screen" class="modal hidden">
            <h1>CRITICAL FAILURE</h1>
            <p id="final-score-text">Distance: 0m</p>
            <button class="btn" id="restart-btn">Retry</button>
        </div>
    </div>

    <script>
        /**
         * PHASE SHIFT
         * Updated with Random Obstacle Types and UI
         */

        // --- CONFIGURATION ---
        const CONFIG = {
            colors: {
                bg: '#050505',
                player: '#00f3ff',
                playerGlow: 'rgba(0, 243, 255, ',
                obstacle: '#ffffff',
                obstacleGlow: 'rgba(255, 255, 255, ',
                mine: '#ffaa00', // Color for the new Diamond/Mine shape
                piston: '#ff0055' // Color for the single block
            },
            physics: {
                gravity: 2800, 
                terminalVelocity: 900,
                baseSpeed: 500, 
                jumpImpulse: 0 
            },
            gameplay: {
                initialGap: 280,
                minGap: 140,
                obstacleWidth: 60,
                spawnDistance: 400, 
                difficultyRamp: 0.05 
            }
        };

        // --- MATH UTILS ---
        const MathUtils = {
            lerp: (a, b, t) => a + (b - a) * t,
            clamp: (val, min, max) => Math.max(min, Math.min(max, val)),
            randRange: (min, max) => Math.random() * (max - min) + min,
            easeOut: (t) => (--t) * t * t + 1
        };

        // --- AUDIO ENGINE ---
        class AudioEngine {
            constructor() {
                this.ctx = null;
                this.masterGain = null;
                this.initialized = false;
            }

            init() {
                if (this.initialized) return;
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.4;
                this.masterGain.connect(this.ctx.destination);
                this.initialized = true;
            }

            playFlip() {
                if (!this.initialized) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, t);
                osc.frequency.exponentialRampToValueAtTime(800, t + 0.1);
                gain.gain.setValueAtTime(0.3, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start(t);
                osc.stop(t + 0.15);
            }

            playScore(multiplier) {
                if (!this.initialized) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const basePitch = 880 + (multiplier * 50); 
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(basePitch, t);
                osc.frequency.exponentialRampToValueAtTime(basePitch * 2, t + 0.05);
                gain.gain.setValueAtTime(0.1, t);
                gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start(t);
                osc.stop(t + 0.1);
            }

            playCrash() {
                if (!this.initialized) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.frequency.setValueAtTime(100, t);
                osc.frequency.exponentialRampToValueAtTime(10, t + 0.5);
                gain.gain.setValueAtTime(0.8, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start(t);
                osc.stop(t + 0.6);
            }
        }

        // --- PARTICLE SYSTEM ---
        class Particle {
            constructor(x, y, color, speed) {
                this.x = x;
                this.y = y;
                this.color = color;
                const angle = Math.random() * Math.PI * 2;
                const velocity = Math.random() * speed;
                this.vx = Math.cos(angle) * velocity;
                this.vy = Math.sin(angle) * velocity;
                this.life = 1.0;
                this.decay = Math.random() * 0.03 + 0.01;
                this.size = Math.random() * 4 + 1;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= this.decay;
                this.vx *= 0.95; 
                this.vy *= 0.95;
            }

            draw(ctx) {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * this.life, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        // --- PLAYER ---
        class Player {
            constructor() {
                this.radius = 12;
                this.x = 0; 
                this.y = 0;
                this.vy = 0;
                this.gravityDir = 1; 
                this.trail = [];
                this.maxTrail = 20;
            }

            reset(width, height) {
                this.x = width * 0.2;
                this.y = height * 0.5;
                this.vy = 0;
                this.gravityDir = 1;
                this.trail = [];
            }

            flip() {
                this.gravityDir *= -1;
                this.vy = this.gravityDir * 150; 
            }

            update(dt, height) {
                const gravity = CONFIG.physics.gravity * this.gravityDir;
                this.vy += gravity * dt;
                this.vy = MathUtils.clamp(this.vy, -CONFIG.physics.terminalVelocity, CONFIG.physics.terminalVelocity);
                this.y += this.vy * dt;

                let collided = false;
                if (this.y < this.radius) {
                    this.y = this.radius;
                    this.vy = 0;
                    collided = true;
                }
                if (this.y > height - this.radius) {
                    this.y = height - this.radius;
                    this.vy = 0;
                    collided = true;
                }

                this.trail.unshift({x: this.x, y: this.y});
                if (this.trail.length > this.maxTrail) this.trail.pop();

                return collided;
            }

            draw(ctx) {
                if (this.trail.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(this.trail[0].x, this.trail[0].y);
                    for (let i = 1; i < this.trail.length; i++) {
                        const p = this.trail[i];
                        ctx.lineTo(p.x, p.y);
                    }
                    const grad = ctx.createLinearGradient(
                        this.trail[0].x, this.trail[0].y, 
                        this.trail[this.trail.length-1].x, this.trail[this.trail.length-1].y
                    );
                    grad.addColorStop(0, CONFIG.colors.player);
                    grad.addColorStop(1, 'rgba(0, 243, 255, 0)');
                    ctx.strokeStyle = grad;
                    ctx.lineWidth = 4;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.stroke();
                }

                ctx.shadowBlur = 20;
                ctx.shadowColor = CONFIG.colors.player;
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();

                ctx.shadowBlur = 0;
                ctx.fillStyle = CONFIG.colors.player;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 0.7, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // --- OBSTACLE MANAGER ---
        class ObstacleManager {
            constructor() {
                this.obstacles = [];
                this.timer = 0;
                this.spawnX = 0;
            }

            reset(width) {
                this.obstacles = [];
                this.timer = 0;
                this.spawnX = width + 100;
            }

            update(dt, speed, width, height, difficulty) {
                for (let i = this.obstacles.length - 1; i >= 0; i--) {
                    let obs = this.obstacles[i];
                    obs.x -= speed * dt;
                    if (obs.x + obs.w < 0) {
                        this.obstacles.splice(i, 1);
                    }
                }

                this.spawnX -= speed * dt;
                
                if (this.spawnX <= width) {
                    this.spawnObstacle(width, height, difficulty);
                    const dist = Math.max(
                        CONFIG.gameplay.spawnDistance * 0.6,
                        CONFIG.gameplay.spawnDistance - (difficulty * 50)
                    );
                    this.spawnX = width + dist;
                }
            }

            spawnObstacle(width, height, difficulty) {
                // Calculate Gap
                let gap = MathUtils.lerp(
                    CONFIG.gameplay.initialGap, 
                    CONFIG.gameplay.minGap, 
                    Math.min(difficulty * 0.1, 1)
                );
                gap += MathUtils.randRange(-20, 20);

                // Safe Zone
                const minY = 50 + gap/2;
                const maxY = height - 50 - gap/2;
                const centerY = MathUtils.randRange(minY, maxY);
                const w = CONFIG.gameplay.obstacleWidth;

                // Determine Type Randomly
                const rand = Math.random();
                let type = 'WALL'; // Default
                if (rand > 0.7) type = 'MINE'; // 30% chance
                else if (rand > 0.4) type = 'PISTON'; // 30% chance

                this.obstacles.push({
                    type: type,
                    x: width,
                    w: w,
                    topH: centerY - gap/2, // For Wall/Piston
                    bottomY: centerY + gap/2, // For Wall/Piston
                    centerY: centerY, // For Mine
                    passed: false
                });
            }

            draw(ctx, height) {
                this.obstacles.forEach(obs => {
                    if (obs.type === 'WALL') {
                        // Standard Top/Bottom Bars
                        ctx.fillStyle = CONFIG.colors.obstacle;
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = CONFIG.colors.obstacleGlow + '0.5)';
                        
                        // Top
                        ctx.fillRect(obs.x, 0, obs.w, obs.topH);
                        // Bottom
                        ctx.fillRect(obs.x, obs.bottomY, obs.w, height - obs.bottomY);
                        
                        // Detail lines
                        ctx.fillStyle = 'rgba(255,255,255,0.8)';
                        ctx.fillRect(obs.x, obs.topH - 5, obs.w, 5);
                        ctx.fillRect(obs.x, obs.bottomY, obs.w, 5);

                    } else if (obs.type === 'MINE') {
                        // Floating Diamond Shape
                        ctx.fillStyle = CONFIG.colors.mine;
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = CONFIG.colors.mine;
                        
                        const size = 50; // Size of the mine
                        const cy = obs.centerY;
                        const cx = obs.x + obs.w/2;
                        
                        ctx.beginPath();
                        ctx.moveTo(cx, cy - size/2); // Top
                        ctx.lineTo(cx + size/2, cy); // Right
                        ctx.moveTo(cx, cy + size/2); // Bottom
                        ctx.lineTo(cx - size/2, cy); // Left
                        ctx.lineTo(cx, cy - size/2);
                        ctx.fill();
                        
                        // Core
                        ctx.fillStyle = '#fff';
                        ctx.beginPath();
                        ctx.arc(cx, cy, 10, 0, Math.PI*2);
                        ctx.fill();

                    } else if (obs.type === 'PISTON') {
                        // Single Block connected to either top or bottom
                        ctx.fillStyle = CONFIG.colors.piston;
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = CONFIG.colors.piston;

                        // Randomly decided earlier implicitly by gap position, 
                        // but let's enforce a solid look.
                        // If center is high, draw from top. If low, draw from bottom.
                        if (obs.centerY < height / 2) {
                            // Ceiling Piston
                            ctx.fillRect(obs.x, 0, obs.w, obs.centerY + 40);
                            ctx.fillStyle = '#fff';
                            ctx.fillRect(obs.x, obs.centerY + 30, obs.w, 10);
                        } else {
                            // Floor Piston
                            ctx.fillRect(obs.x, obs.centerY - 40, obs.w, height);
                            ctx.fillStyle = '#fff';
                            ctx.fillRect(obs.x, obs.centerY - 40, obs.w, 10);
                        }
                    }
                    ctx.shadowBlur = 0;
                });
            }

            checkCollision(player) {
                const pR = player.radius * 0.8; // Hitbox reduction
                
                for (let obs of this.obstacles) {
                    if (player.x + pR > obs.x && player.x - pR < obs.x + obs.w) {
                        
                        if (obs.type === 'WALL') {
                            if (player.y - pR < obs.topH) return true;
                            if (player.y + pR > obs.bottomY) return true;
                        
                        } else if (obs.type === 'MINE') {
                            // Simple box collision for the mine for performance
                            // Check if player is INSIDE the mine area
                            const size = 40; // Hitbox size
                            if (player.y + pR > obs.centerY - size/2 && 
                                player.y - pR < obs.centerY + size/2) {
                                return true;
                            }

                        } else if (obs.type === 'PISTON') {
                            const height = window.innerHeight; // Approx check
                            if (obs.centerY < height / 2) {
                                // Checking Ceiling Piston collision
                                if (player.y - pR < obs.centerY + 40) return true;
                            } else {
                                // Checking Floor Piston collision
                                if (player.y + pR > obs.centerY - 40) return true;
                            }
                        }
                    }
                }
                return false;
            }

            checkScore(player) {
                let scoreAdded = 0;
                this.obstacles.forEach(obs => {
                    if (!obs.passed && player.x > obs.x + obs.w) {
                        obs.passed = true;
                        scoreAdded = 1;
                    }
                });
                return scoreAdded;
            }
        }

        // --- GAME CORE ---
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d', { alpha: false });
                
                this.width = window.innerWidth;
                this.height = window.innerHeight;

                this.audio = new AudioEngine();
                this.player = new Player();
                this.obstacles = new ObstacleManager();
                this.particles = [];

                this.state = 'MENU';
                this.score = 0;
                this.distance = 0;
                this.difficulty = 0;
                this.gameSpeed = CONFIG.physics.baseSpeed;

                this.lastTime = 0;
                this.shakeTime = 0;

                this.scoreDisplay = document.getElementById('score-display');
                this.startScreen = document.getElementById('start-screen');
                this.gameOverScreen = document.getElementById('gameover-screen');
                this.flash = document.getElementById('flash');

                this.resize();
                window.addEventListener('resize', () => this.resize());
                this.setupInputs();

                requestAnimationFrame(t => this.loop(t));
            }

            resize() {
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                this.canvas.width = this.width * window.devicePixelRatio;
                this.canvas.height = this.height * window.devicePixelRatio;
                this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            }

            setupInputs() {
                const action = (e) => {
                    e.preventDefault();
                    if (this.state === 'MENU') {
                        this.startGame();
                    } else if (this.state === 'PLAYING') {
                        this.player.flip();
                        this.audio.playFlip();
                    } else if (this.state === 'GAMEOVER') {
                        if (Date.now() - this.deathTime > 500) {
                            this.resetGame();
                            this.startGame();
                        }
                    }
                };

                window.addEventListener('mousedown', action);
                window.addEventListener('touchstart', action, {passive: false});
                window.addEventListener('keydown', (e) => {
                    if (e.code === 'Space') action(e);
                });

                document.getElementById('start-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.startGame();
                });

                document.getElementById('restart-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.resetGame();
                    this.startGame();
                });
            }

            resetGame() {
                this.score = 0;
                this.distance = 0;
                this.difficulty = 0;
                this.gameSpeed = CONFIG.physics.baseSpeed;
                this.particles = [];
                this.player.reset(this.width, this.height);
                this.obstacles.reset(this.width);
                this.scoreDisplay.innerText = "0";
                this.startScreen.classList.add('hidden');
                this.gameOverScreen.classList.add('hidden');
            }

            startGame() {
                this.audio.init();
                this.state = 'PLAYING';
                this.lastTime = performance.now();
                this.resetGame();
            }

            die() {
                this.state = 'GAMEOVER';
                this.deathTime = Date.now();
                this.audio.playCrash();
                this.shakeTime = 0.5;
                this.flash.style.opacity = 0.8;
                setTimeout(() => this.flash.style.opacity = 0, 50);

                for(let i=0; i<30; i++) {
                    this.particles.push(new Particle(this.player.x, this.player.y, CONFIG.colors.player, 30));
                }

                document.getElementById('final-score-text').innerText = `Distance: ${Math.floor(this.distance)}m`;
                this.gameOverScreen.classList.remove('hidden');
            }

            update(dt) {
                if (this.state !== 'PLAYING') {
                    if (this.state === 'GAMEOVER') this.updateParticles();
                    return;
                }

                this.difficulty += dt * CONFIG.gameplay.difficultyRamp;
                let speedMultiplier = 1 + Math.log10(1 + this.difficulty * 0.5);
                this.gameSpeed = CONFIG.physics.baseSpeed * speedMultiplier;

                this.distance += (this.gameSpeed * dt) / 50; 
                const wallHit = this.player.update(dt, this.height);

                this.obstacles.update(dt, this.gameSpeed, this.width, this.height, this.difficulty);

                if (wallHit || this.obstacles.checkCollision(this.player)) {
                    this.die();
                }

                const points = this.obstacles.checkScore(this.player);
                if (points > 0) {
                    this.score += points;
                    this.audio.playScore(speedMultiplier);
                    this.scoreDisplay.style.transform = "scale(1.2)";
                    setTimeout(() => this.scoreDisplay.style.transform = "scale(1)", 100);
                }

                this.scoreDisplay.innerText = Math.floor(this.distance);
                this.updateParticles();
                if (this.shakeTime > 0) this.shakeTime -= dt;
            }

            updateParticles() {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    let p = this.particles[i];
                    p.update();
                    if (p.life <= 0) this.particles.splice(i, 1);
                }
            }

            draw() {
                this.ctx.fillStyle = CONFIG.colors.bg;
                this.ctx.fillRect(0, 0, this.width, this.height);
                this.drawBackgroundGrid();

                this.ctx.save();
                if (this.shakeTime > 0) {
                    const mag = this.shakeTime * 20;
                    this.ctx.translate((Math.random() - 0.5) * mag, (Math.random() - 0.5) * mag);
                }

                this.obstacles.draw(this.ctx, this.height);
                if (this.state === 'PLAYING') this.player.draw(this.ctx);
                this.particles.forEach(p => p.draw(this.ctx));
                this.ctx.restore();
            }

            drawBackgroundGrid() {
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.03)';
                this.ctx.lineWidth = 1;
                const spacing = 100;
                const offset = -(this.distance * 50) % spacing;
                
                for (let x = offset; x < this.width; x += spacing) {
                    if (x < 0) continue;
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.height);
                    this.ctx.stroke();
                }

                this.ctx.beginPath();
                this.ctx.moveTo(0, this.height * 0.2);
                this.ctx.lineTo(this.width, this.height * 0.2);
                this.ctx.moveTo(0, this.height * 0.8);
                this.ctx.lineTo(this.width, this.height * 0.8);
                this.ctx.stroke();
            }

            loop(time) {
                const dt = Math.min((time - this.lastTime) / 1000, 0.05);
                this.lastTime = time;
                this.update(dt);
                this.draw();
                requestAnimationFrame(t => this.loop(t));
            }
        }

        window.onload = () => { const game = new Game(); };

    </script>
</body>
</html>
