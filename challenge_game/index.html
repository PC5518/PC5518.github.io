<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PHASE SHIFT</title>
    <style>
        :root {
            --bg-color: #050505;
            --accent-color: #00f3ff;
            --accent-glow: rgba(0, 243, 255, 0.6);
            --enemy-color: #ff0055;
            --enemy-glow: rgba(255, 0, 85, 0.4);
            --ui-font: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: var(--ui-font);
        }

        /* Scanline overlay for retro-modern feel */
        body::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(
                to bottom,
                rgba(255, 255, 255, 0),
                rgba(255, 255, 255, 0) 50%,
                rgba(0, 0, 0, 0.1) 50%,
                rgba(0, 0, 0, 0.1)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
        }

        .score-container {
            position: absolute;
            top: 40px;
            text-align: center;
            opacity: 0.8;
            transition: transform 0.1s;
        }

        #score-display {
            font-size: 4rem;
            font-weight: 800;
            color: white;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
            letter-spacing: -2px;
            margin: 0;
        }

        #score-label {
            font-size: 0.8rem;
            color: var(--accent-color);
            text-transform: uppercase;
            letter-spacing: 4px;
            margin-top: 5px;
            font-weight: 600;
        }

        /* Start / Game Over Screen */
        .modal {
            background: rgba(5, 5, 5, 0.85);
            backdrop-filter: blur(10px);
            padding: 40px 60px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            text-align: center;
            transform: translateY(0);
            transition: opacity 0.3s, transform 0.3s;
            pointer-events: auto;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
        }

        .modal.hidden {
            opacity: 0;
            transform: translateY(20px);
            pointer-events: none;
        }

        h1 {
            color: white;
            font-size: 3rem;
            margin: 0 0 10px 0;
            font-weight: 900;
            letter-spacing: -1px;
            background: linear-gradient(45deg, #fff, var(--accent-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        p {
            color: #aaa;
            font-size: 1rem;
            margin: 0 0 30px 0;
            line-height: 1.5;
        }

        .btn {
            background: transparent;
            color: var(--accent-color);
            border: 2px solid var(--accent-color);
            padding: 15px 40px;
            font-size: 1.2rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
            font-family: var(--ui-font);
        }

        .btn:hover {
            background: var(--accent-color);
            color: #000;
            box-shadow: 0 0 30px var(--accent-glow);
        }

        .instructions {
            margin-top: 20px;
            font-size: 0.8rem;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        /* Flash effect on impact */
        #flash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: white;
            opacity: 0;
            pointer-events: none;
            z-index: 30;
            transition: opacity 0.1s;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>
    <div id="flash"></div>

    <div id="ui-layer">
        <div class="score-container" id="score-container">
            <h2 id="score-display">0</h2>
            <div id="score-label">Distance</div>
        </div>

        <div id="start-screen" class="modal">
            <h1>PHASE SHIFT</h1>
            <p>Procedural Obstacle Evasion</p>
            <button class="btn" id="start-btn">Initialize</button>
            <div class="instructions">Click or Space to Invert Gravity</div>
        </div>

        <div id="gameover-screen" class="modal hidden">
            <h1>CRITICAL FAILURE</h1>
            <p id="final-score-text">Distance: 0m</p>
            <button class="btn" id="restart-btn">Retry</button>
        </div>
    </div>

    <script>
        /**
         * PHASE SHIFT
         * A high-fidelity procedural runner.
         */

        // --- CONFIGURATION ---
        const CONFIG = {
            colors: {
                bg: '#050505',
                player: '#00f3ff',
                playerGlow: 'rgba(0, 243, 255, ',
                obstacle: '#ffffff',
                obstacleGlow: 'rgba(255, 255, 255, ',
                danger: '#ff0055'
            },
            physics: {
                gravity: 2800, // Pixels per second squared
                terminalVelocity: 900,
                baseSpeed: 500, // Horizontal pixels per second
                jumpImpulse: 0 // No jump, just gravity flip
            },
            gameplay: {
                initialGap: 280,
                minGap: 140,
                obstacleWidth: 60,
                spawnDistance: 400, // Distance between pipes
                difficultyRamp: 0.05 // How fast it gets hard
            }
        };

        // --- MATH UTILS ---
        const MathUtils = {
            lerp: (a, b, t) => a + (b - a) * t,
            clamp: (val, min, max) => Math.max(min, Math.min(max, val)),
            randRange: (min, max) => Math.random() * (max - min) + min,
            easeOut: (t) => (--t) * t * t + 1
        };

        // --- AUDIO ENGINE (Procedural Sound) ---
        class AudioEngine {
            constructor() {
                this.ctx = null;
                this.masterGain = null;
                this.initialized = false;
                this.droneOsc = null;
            }

            init() {
                if (this.initialized) return;
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.4;
                this.masterGain.connect(this.ctx.destination);

                // Create a compressor to glue sounds together
                const compressor = this.ctx.createDynamicsCompressor();
                compressor.threshold.value = -24;
                compressor.knee.value = 30;
                compressor.ratio.value = 12;
                compressor.attack.value = 0.003;
                compressor.release.value = 0.25;
                this.masterGain.connect(compressor);
                compressor.connect(this.ctx.destination);

                this.startAmbientDrone();
                this.initialized = true;
            }

            startAmbientDrone() {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();

                osc.type = 'sawtooth';
                osc.frequency.value = 50; 
                
                filter.type = 'lowpass';
                filter.frequency.value = 200;
                filter.Q.value = 1;

                gain.gain.value = 0.1;

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                
                osc.start();
                this.droneOsc = { osc, filter, gain };

                // Modulate the filter for "life"
                setInterval(() => {
                    if(this.ctx.state === 'running') {
                        const time = this.ctx.currentTime;
                        filter.frequency.setValueAtTime(200 + Math.sin(time * 0.5) * 50, time);
                    }
                }, 100);
            }

            playFlip() {
                if (!this.initialized) return;
                const t = this.ctx.currentTime;
                
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, t);
                osc.frequency.exponentialRampToValueAtTime(800, t + 0.1);
                
                gain.gain.setValueAtTime(0.3, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                
                osc.connect(gain);
                gain.connect(this.masterGain);
                
                osc.start(t);
                osc.stop(t + 0.15);
            }

            playScore(multiplier) {
                if (!this.initialized) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                const basePitch = 880 + (multiplier * 50); 
                
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(basePitch, t);
                osc.frequency.exponentialRampToValueAtTime(basePitch * 2, t + 0.05);
                
                gain.gain.setValueAtTime(0.1, t);
                gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
                
                osc.connect(gain);
                gain.connect(this.masterGain);
                
                osc.start(t);
                osc.stop(t + 0.1);
            }

            playCrash() {
                if (!this.initialized) return;
                const t = this.ctx.currentTime;
                
                // Noise burst
                const bufferSize = this.ctx.sampleRate * 0.5;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(1000, t);
                filter.frequency.exponentialRampToValueAtTime(100, t + 0.4);

                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0.8, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
                
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                
                noise.start(t);

                // Sub bass impact
                const osc = this.ctx.createOscillator();
                const subGain = this.ctx.createGain();
                osc.frequency.setValueAtTime(100, t);
                osc.frequency.exponentialRampToValueAtTime(10, t + 0.5);
                subGain.gain.setValueAtTime(0.8, t);
                subGain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
                
                osc.connect(subGain);
                subGain.connect(this.masterGain);
                osc.start(t);
                osc.stop(t + 0.6);
            }
        }

        // --- PARTICLE SYSTEM ---
        class Particle {
            constructor(x, y, color, speed) {
                this.x = x;
                this.y = y;
                this.color = color;
                const angle = Math.random() * Math.PI * 2;
                const velocity = Math.random() * speed;
                this.vx = Math.cos(angle) * velocity;
                this.vy = Math.sin(angle) * velocity;
                this.life = 1.0;
                this.decay = Math.random() * 0.03 + 0.01;
                this.size = Math.random() * 4 + 1;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= this.decay;
                this.vx *= 0.95; // Friction
                this.vy *= 0.95;
            }

            draw(ctx) {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * this.life, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        // --- ENTITIES ---
        
        class Player {
            constructor() {
                this.radius = 12;
                this.x = 0; // Will be set in reset
                this.y = 0;
                this.vy = 0;
                this.gravityDir = 1; // 1 = down, -1 = up
                this.trail = [];
                this.maxTrail = 20;
            }

            reset(width, height) {
                this.x = width * 0.2;
                this.y = height * 0.5;
                this.vy = 0;
                this.gravityDir = 1;
                this.trail = [];
            }

            flip() {
                this.gravityDir *= -1;
                this.vy = this.gravityDir * 150; 
            }

            update(dt, height) {
                // Physics
                const gravity = CONFIG.physics.gravity * this.gravityDir;
                this.vy += gravity * dt;
                
                // Clamp velocity
                this.vy = MathUtils.clamp(
                    this.vy, 
                    -CONFIG.physics.terminalVelocity, 
                    CONFIG.physics.terminalVelocity
                );

                this.y += this.vy * dt;

                // Bounds collision
                let collided = false;
                if (this.y < this.radius) {
                    this.y = this.radius;
                    this.vy = 0;
                    collided = true;
                }
                if (this.y > height - this.radius) {
                    this.y = height - this.radius;
                    this.vy = 0;
                    collided = true;
                }

                // Trail Logic
                this.trail.unshift({x: this.x, y: this.y});
                if (this.trail.length > this.maxTrail) {
                    this.trail.pop();
                }

                return collided;
            }

            draw(ctx) {
                // Draw Trail
                if (this.trail.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(this.trail[0].x, this.trail[0].y);
                    for (let i = 1; i < this.trail.length; i++) {
                        const p = this.trail[i];
                        ctx.lineTo(p.x, p.y);
                    }
                    
                    const grad = ctx.createLinearGradient(
                        this.trail[0].x, this.trail[0].y, 
                        this.trail[this.trail.length-1].x, this.trail[this.trail.length-1].y
                    );
                    grad.addColorStop(0, CONFIG.colors.player);
                    grad.addColorStop(1, 'rgba(0, 243, 255, 0)');
                    
                    ctx.strokeStyle = grad;
                    ctx.lineWidth = 4;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = CONFIG.colors.player;
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }

                // Draw Player
                ctx.shadowBlur = 20;
                ctx.shadowColor = CONFIG.colors.player;
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();

                // Inner Glow
                ctx.shadowBlur = 0;
                ctx.fillStyle = CONFIG.colors.player;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 0.7, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class ObstacleManager {
            constructor() {
                this.obstacles = [];
                this.timer = 0;
                this.spawnX = 0;
            }

            reset(width) {
                this.obstacles = [];
                this.timer = 0;
                this.spawnX = width + 100;
            }

            update(dt, speed, width, height, difficulty) {
                // Move obstacles
                for (let i = this.obstacles.length - 1; i >= 0; i--) {
                    let obs = this.obstacles[i];
                    obs.x -= speed * dt;

                    // Remove if offscreen
                    if (obs.x + obs.w < 0) {
                        this.obstacles.splice(i, 1);
                    }
                }

                // Spawn logic
                this.spawnX -= speed * dt;
                
                if (this.spawnX <= width) {
                    this.spawnObstacle(width, height, difficulty);
                    
                    const dist = Math.max(
                        CONFIG.gameplay.spawnDistance * 0.6,
                        CONFIG.gameplay.spawnDistance - (difficulty * 50)
                    );
                    this.spawnX = width + dist;
                }
            }

            spawnObstacle(width, height, difficulty) {
                // Calculate Gap Size
                let gap = MathUtils.lerp(
                    CONFIG.gameplay.initialGap, 
                    CONFIG.gameplay.minGap, 
                    Math.min(difficulty * 0.1, 1)
                );

                gap += MathUtils.randRange(-20, 20);

                // Calculate Gap Position
                const minY = 50 + gap/2;
                const maxY = height - 50 - gap/2;
                
                const centerY = MathUtils.randRange(minY, maxY);

                const w = CONFIG.gameplay.obstacleWidth;

                this.obstacles.push({
                    x: width,
                    w: w,
                    topH: centerY - gap/2,
                    bottomY: centerY + gap/2,
                    passed: false
                });
            }

            draw(ctx, height) {
                ctx.fillStyle = CONFIG.colors.obstacle;
                ctx.shadowBlur = 10;
                ctx.shadowColor = CONFIG.colors.obstacleGlow + '0.5)';

                this.obstacles.forEach(obs => {
                    // Top Pillar
                    ctx.fillRect(obs.x, 0, obs.w, obs.topH);
                    
                    // Bottom Pillar
                    ctx.fillRect(obs.x, obs.bottomY, obs.w, height - obs.bottomY);
                    
                    // Add subtle detail
                    ctx.fillStyle = 'rgba(255,255,255,0.8)';
                    ctx.fillRect(obs.x, obs.topH - 5, obs.w, 5);
                    ctx.fillRect(obs.x, obs.bottomY, obs.w, 5);
                    ctx.fillStyle = CONFIG.colors.obstacle;
                });
                
                ctx.shadowBlur = 0;
            }

            checkCollision(player) {
                for (let obs of this.obstacles) {
                    // AABB Collision
                    const pR = player.radius * 0.8;
                    
                    // Check X overlap
                    if (player.x + pR > obs.x && player.x - pR < obs.x + obs.w) {
                        // Check Y overlap (Top pipe)
                        if (player.y - pR < obs.topH) return true;
                        // Check Y overlap (Bottom pipe)
                        if (player.y + pR > obs.bottomY) return true;
                    }
                }
                return false;
            }

            checkScore(player) {
                let scoreAdded = 0;
                this.obstacles.forEach(obs => {
                    if (!obs.passed && player.x > obs.x + obs.w) {
                        obs.passed = true;
                        scoreAdded = 1;
                    }
                });
                return scoreAdded;
            }
        }

        // --- GAME CORE ---
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d', { alpha: false });
                
                this.width = window.innerWidth;
                this.height = window.innerHeight;

                this.audio = new AudioEngine();
                this.player = new Player();
                this.obstacles = new ObstacleManager();
                this.particles = [];

                this.state = 'MENU'; // MENU, PLAYING, GAMEOVER
                this.score = 0;
                this.distance = 0;
                this.difficulty = 0;
                this.gameSpeed = CONFIG.physics.baseSpeed;

                this.lastTime = 0;
                this.shakeTime = 0;

                // Elements
                this.scoreDisplay = document.getElementById('score-display');
                this.startScreen = document.getElementById('start-screen');
                this.gameOverScreen = document.getElementById('gameover-screen');
                this.flash = document.getElementById('flash');

                this.resize();
                window.addEventListener('resize', () => this.resize());
                this.setupInputs();

                // Start Loop
                requestAnimationFrame(t => this.loop(t));
            }

            resize() {
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                this.canvas.width = this.width * window.devicePixelRatio;
                this.canvas.height = this.height * window.devicePixelRatio;
                this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            }

            setupInputs() {
                const action = (e) => {
                    e.preventDefault();
                    if (this.state === 'MENU') {
                        this.startGame();
                    } else if (this.state === 'PLAYING') {
                        this.player.flip();
                        this.audio.playFlip();
                    } else if (this.state === 'GAMEOVER') {
                        if (Date.now() - this.deathTime > 500) {
                            this.resetGame();
                            this.startGame();
                        }
                    }
                };

                window.addEventListener('mousedown', action);
                window.addEventListener('touchstart', action, {passive: false});
                window.addEventListener('keydown', (e) => {
                    if (e.code === 'Space') action(e);
                });

                document.getElementById('start-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.startGame();
                });

                document.getElementById('restart-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.resetGame();
                    this.startGame();
                });
            }

            resetGame() {
                this.score = 0;
                this.distance = 0;
                this.difficulty = 0;
                this.gameSpeed = CONFIG.physics.baseSpeed;
                this.particles = [];
                this.player.reset(this.width, this.height);
                this.obstacles.reset(this.width);
                this.scoreDisplay.innerText = "0";
                
                // UI Reset
                this.startScreen.classList.add('hidden');
                this.gameOverScreen.classList.add('hidden');
            }

            startGame() {
                this.audio.init();
                this.state = 'PLAYING';
                this.lastTime = performance.now();
                this.resetGame();
            }

            die() {
                this.state = 'GAMEOVER';
                this.deathTime = Date.now();
                this.audio.playCrash();
                
                // Screen Shake
                this.shakeTime = 0.5; // seconds
                
                // Flash
                this.flash.style.opacity = 0.8;
                setTimeout(() => this.flash.style.opacity = 0, 50);

                // Particles
                for(let i=0; i<30; i++) {
                    this.particles.push(new Particle(
                        this.player.x, 
                        this.player.y, 
                        CONFIG.colors.player, 
                        30
                    ));
                }

                document.getElementById('final-score-text').innerText = `Distance: ${Math.floor(this.distance)}m`;
                this.gameOverScreen.classList.remove('hidden');
            }

            update(dt) {
                if (this.state !== 'PLAYING') {
                    // Just update particles if in gameover
                    if (this.state === 'GAMEOVER') {
                        this.updateParticles();
                    }
                    return;
                }

                const timeInSec = this.distance / (CONFIG.physics.baseSpeed / 60); // approx
                
                this.difficulty += dt * CONFIG.gameplay.difficultyRamp;
                
                // Speed Log curve: Caps at ~1.8x speed
                let speedMultiplier = 1 + Math.log10(1 + this.difficulty * 0.5);
                this.gameSpeed = CONFIG.physics.baseSpeed * speedMultiplier;

                // 2. Physics
                this.distance += (this.gameSpeed * dt) / 50; // Distance in "meters"
                const wallHit = this.player.update(dt, this.height);

                // 3. Obstacles
                this.obstacles.update(dt, this.gameSpeed, this.width, this.height, this.difficulty);

                // 4. Collision
                if (wallHit || this.obstacles.checkCollision(this.player)) {
                    this.die();
                }

                // 5. Score
                const points = this.obstacles.checkScore(this.player);
                if (points > 0) {
                    this.score += points;
                    this.audio.playScore(speedMultiplier);
                    
                    // UI Bump
                    this.scoreDisplay.style.transform = "scale(1.2)";
                    setTimeout(() => this.scoreDisplay.style.transform = "scale(1)", 100);
                }

                this.scoreDisplay.innerText = Math.floor(this.distance);
                
                // 6. Particles
                this.updateParticles();

                // 7. Screen Shake decay
                if (this.shakeTime > 0) this.shakeTime -= dt;
            }

            updateParticles() {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    let p = this.particles[i];
                    p.update();
                    if (p.life <= 0) this.particles.splice(i, 1);
                }
            }

            draw() {
                // Clear Background
                this.ctx.fillStyle = CONFIG.colors.bg;
                this.ctx.fillRect(0, 0, this.width, this.height);

                // Grid/Floor illusion for depth
                this.drawBackgroundGrid();

                // Apply Shake
                this.ctx.save();
                if (this.shakeTime > 0) {
                    const mag = this.shakeTime * 20;
                    const dx = (Math.random() - 0.5) * mag;
                    const dy = (Math.random() - 0.5) * mag;
                    this.ctx.translate(dx, dy);
                }

                // Draw Entities
                this.obstacles.draw(this.ctx, this.height);
                
                if (this.state === 'PLAYING') {
                    this.player.draw(this.ctx);
                }

                // Draw Particles
                this.particles.forEach(p => p.draw(this.ctx));

                this.ctx.restore();
            }

            drawBackgroundGrid() {
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.03)';
                this.ctx.lineWidth = 1;
                
                // Moving vertical lines
                const spacing = 100;
                // Offset based on distance to create movement sensation
                const offset = -(this.distance * 50) % spacing;
                
                for (let x = offset; x < this.width; x += spacing) {
                    if (x < 0) continue;
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.height);
                    this.ctx.stroke();
                }

                // Horizontal horizon lines
                this.ctx.beginPath();
                this.ctx.moveTo(0, this.height * 0.2);
                this.ctx.lineTo(this.width, this.height * 0.2);
                this.ctx.moveTo(0, this.height * 0.8);
                this.ctx.lineTo(this.width, this.height * 0.8);
                this.ctx.stroke();
            }

            loop(time) {
                const dt = Math.min((time - this.lastTime) / 1000, 0.05); // Cap dt
                this.lastTime = time;

                this.update(dt);
                this.draw();

                requestAnimationFrame(t => this.loop(t));
            }
        }

        // Initialize
        window.onload = () => {
            const game = new Game();
        };

    </script>
</body>
</html>
