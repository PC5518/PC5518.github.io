<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>FLUX | Kinetic Momentum</title>
    <style>
        /* 
        ========================================
        CSS STYLING
        Minimalist, Dark, Fullscreen
        ========================================
        */
        :root {
            --bg-color: #0b0c10;
            --text-color: #66fcf1;
            --accent-color: #45a29e;
            --font-main: 'Courier New', Courier, monospace;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-main);
            user-select: none;
            -webkit-user-select: none;
            cursor: pointer; /* Suggest interactivity */
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            display: block;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
        }

        /* UI OVERLAY LAYER */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let clicks pass through to game */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 2rem;
            box-sizing: border-box;
            z-index: 10;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .score-display {
            font-size: 2rem;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(102, 252, 241, 0.5);
        }

        .score-label {
            font-size: 0.8rem;
            opacity: 0.7;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .center-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .center-message.visible {
            opacity: 1;
        }

        h1 {
            font-size: 4rem;
            margin: 0 0 1rem 0;
            letter-spacing: -2px;
            color: #fff;
            text-shadow: 0 0 20px rgba(102, 252, 241, 0.3);
        }

        p.sub {
            font-size: 1rem;
            letter-spacing: 4px;
            color: var(--accent-color);
            text-transform: uppercase;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }

        .tutorial-hint {
            position: absolute;
            bottom: 20%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.8rem;
            opacity: 0.5;
            letter-spacing: 1px;
            transition: opacity 0.5s;
        }

        .hidden {
            opacity: 0 !important;
        }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="stage"></canvas>
    
    <div class="ui-layer">
        <div class="hud-top">
            <div>
                <div class="score-label">Current</div>
                <div class="score-display" id="score">0000</div>
            </div>
            <div style="text-align: right;">
                <div class="score-label">Best</div>
                <div class="score-display" id="high-score">0000</div>
            </div>
        </div>

        <div id="start-screen" class="center-message visible">
            <h1>FLUX</h1>
            <p class="sub">Click to Reverse Gravity</p>
            <div style="margin-top: 30px; font-size: 0.7rem; color: #555;">AUDIO ENABLED // HEADPHONES RECOMMENDED</div>
        </div>

        <div id="game-over-screen" class="center-message">
            <h1 style="color: #ff4d4d; text-shadow: 0 0 20px rgba(255, 77, 77, 0.4);">SYNC LOST</h1>
            <p class="sub">Click to Restart</p>
        </div>

        <div id="tutorial" class="tutorial-hint">Avoid the signals. Maintain momentum.</div>
    </div>
</div>

<script>
/**
 * ============================================================================
 * FLUX ENGINE
 * A high-performance, vanilla JS game engine for the specific mechanics of FLUX.
 * 
 * Architecture:
 * 1. CONSTANTS & CONFIG
 * 2. UTILITIES (Math, Random)
 * 3. AUDIO SYSTEM (Procedural Synthesis)
 * 4. PARTICLE SYSTEM (Visual FX)
 * 5. ENTITIES (Player, Obstacles)
 * 6. GAME LOOP & STATE MANAGEMENT
 * 7. RENDERER
 * 8. INPUT HANDLING
 * ============================================================================
 */

/* ==========================================================================
   1. CONSTANTS & CONFIGURATION
   Centralized tuning for gameplay feel.
   ========================================================================== */
const CONFIG = {
    // Physics
    GRAVITY_FORCE: 2500,     // Pixel acceleration per second squared
    TERMINAL_VELOCITY: 800,  // Max vertical speed
    FORWARD_SPEED_BASE: 300, // Pixels per second
    FORWARD_SPEED_MAX: 700,  // Cap on difficulty speedup
    SPEED_INC_PER_SEC: 5,    // How much speed increases per second of survival

    // Player
    PLAYER_SIZE: 20,
    PLAYER_COLOR: '#66fcf1',
    PLAYER_GLOW: '#45a29e',

    // Obstacles
    OBSTACLE_WIDTH: 60,
    GAP_SIZE_BASE: 250,      // Starting gap height
    GAP_SIZE_MIN: 140,       // Minimum gap height at max difficulty
    SPAWN_DISTANCE: 400,     // Distance between obstacles

    // Visuals
    PARTICLE_COUNT_DEATH: 50,
    TRAIL_LENGTH: 10,
    BG_GRID_SIZE: 100,
    
    // Audio frequencies
    TONE_FLIP_UP: 600,
    TONE_FLIP_DOWN: 400,
    TONE_SCORE: 880
};

/* ==========================================================================
   2. UTILITIES
   Math helpers and generic tools.
   ========================================================================== */
const Utils = {
    lerp: (start, end, amt) => (1 - amt) * start + amt * end,
    
    clamp: (val, min, max) => Math.max(min, Math.min(max, val)),
    
    randRange: (min, max) => Math.random() * (max - min) + min,
    
    // AABB Collision Detection
    rectIntersect: (r1, r2) => {
        return !(r2.left > r1.right || 
                 r2.right < r1.left || 
                 r2.top > r1.bottom || 
                 r2.bottom < r1.top);
    },

    // Easing function for smooth animations
    easeOutExpo: (x) => {
        return x === 1 ? 1 : 1 - Math.pow(2, -10 * x);
    }
};

/* ==========================================================================
   3. AUDIO SYSTEM
   Procedural audio generation using Web Audio API.
   No external assets required.
   ========================================================================== */
class AudioController {
    constructor() {
        this.ctx = null;
        this.masterGain = null;
        this.initialized = false;
        
        // Procedural settings
        this.baseFreq = 110; 
    }

    init() {
        if (this.initialized) return;
        
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
        
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.3; // Prevent clipping
        this.masterGain.connect(this.ctx.destination);
        
        // Start background ambience
        this.startDrone();
        
        this.initialized = true;
    }

    startDrone() {
        // Low frequency hum
        const osc = this.ctx.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.value = 55;
        
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 200;
        
        // LFO for movement in the drone
        const lfo = this.ctx.createOscillator();
        lfo.type = 'sine';
        lfo.frequency.value = 0.1;
        const lfoGain = this.ctx.createGain();
        lfoGain.gain.value = 100;
        
        lfo.connect(lfoGain);
        lfoGain.connect(filter.frequency);
        
        const vol = this.ctx.createGain();
        vol.gain.value = 0.4;
        
        osc.connect(filter);
        filter.connect(vol);
        vol.connect(this.masterGain);
        
        osc.start();
        lfo.start();
    }

    playFlip(direction) {
        if (!this.ctx) return;
        const t = this.ctx.currentTime;
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.type = 'triangle';
        // Pitch bend based on direction
        const startFreq = direction === 1 ? CONFIG.TONE_FLIP_DOWN : CONFIG.TONE_FLIP_UP;
        const endFreq = direction === 1 ? CONFIG.TONE_FLIP_UP : CONFIG.TONE_FLIP_DOWN;
        
        osc.frequency.setValueAtTime(startFreq, t);
        osc.frequency.exponentialRampToValueAtTime(endFreq, t + 0.1);
        
        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(0.3, t + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
        
        osc.connect(gain);
        gain.connect(this.masterGain);
        
        osc.start(t);
        osc.stop(t + 0.2);
    }

    playScore() {
        if (!this.ctx) return;
        const t = this.ctx.currentTime;
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.type = 'sine';
        osc.frequency.setValueAtTime(880, t);
        osc.frequency.exponentialRampToValueAtTime(1760, t + 0.1);
        
        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(0.1, t + 0.05);
        gain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
        
        osc.connect(gain);
        gain.connect(this.masterGain);
        
        osc.start(t);
        osc.stop(t + 0.3);
    }

    playCrash() {
        if (!this.ctx) return;
        const t = this.ctx.currentTime;
        
        // Noise buffer
        const bufferSize = this.ctx.sampleRate * 0.5; // 0.5 sec
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }

        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(1000, t);
        filter.frequency.exponentialRampToValueAtTime(100, t + 0.4);

        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0.5, t);
        gain.gain.exponentialRampToValueAtTime(0.001, t + 0.4);

        noise.connect(filter);
        filter.connect(gain);
        gain.connect(this.masterGain);
        
        noise.start(t);
    }
}

/* ==========================================================================
   4. PARTICLE SYSTEM
   For trails and explosions.
   ========================================================================== */
class Particle {
    constructor(x, y, color, speed, lifeTime) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * speed;
        this.vy = (Math.random() - 0.5) * speed;
        this.life = 1.0;
        this.decay = 1.0 / lifeTime;
        this.color = color;
        this.size = Math.random() * 4 + 1;
    }

    update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.life -= this.decay * dt;
    }

    draw(ctx) {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.rect(this.x, this.y, this.size, this.size);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }
}

class ParticleSystem {
    constructor() {
        this.particles = [];
    }

    emit(x, y, count, color, speed = 200) {
        for (let i = 0; i < count; i++) {
            this.particles.push(new Particle(x, y, color, speed, Utils.randRange(0.5, 1.5)));
        }
    }

    emitTrail(x, y, color) {
        // Trails drift backwards relative to player movement
        const p = new Particle(x, y, color, 10, 0.4);
        p.vx = -100; // Move left
        p.vy = (Math.random() - 0.5) * 20;
        this.particles.push(p);
    }

    update(dt) {
        for (let i = this.particles.length - 1; i >= 0; i--) {
            const p = this.particles[i];
            p.update(dt);
            if (p.life <= 0) {
                this.particles.splice(i, 1);
            }
        }
    }

    draw(ctx) {
        for (const p of this.particles) {
            p.draw(ctx);
        }
    }
    
    clear() {
        this.particles = [];
    }
}

/* ==========================================================================
   5. ENTITIES
   Player and Obstacle logic.
   ========================================================================== */
class Player {
    constructor(x, y) {
        this.startX = x;
        this.startY = y;
        this.reset();
    }

    reset() {
        this.x = this.startX;
        this.y = this.startY;
        this.vy = 0;
        this.gravityDir = 1; // 1 = Down, -1 = Up
        this.width = CONFIG.PLAYER_SIZE;
        this.height = CONFIG.PLAYER_SIZE;
        this.isDead = false;
        this.rotation = 0;
    }

    flip() {
        if (this.isDead) return;
        this.gravityDir *= -1;
        // Small impulse to make it feel responsive immediately
        // this.vy = this.gravityDir * 50; 
    }

    update(dt) {
        if (this.isDead) return;

        // Apply gravity acceleration based on direction
        // If gravityDir is 1, we accelerate down (+y)
        // If gravityDir is -1, we accelerate up (-y)
        const acc = CONFIG.GRAVITY_FORCE * this.gravityDir;
        
        this.vy += acc * dt;
        
        // Clamp velocity
        this.vy = Utils.clamp(this.vy, -CONFIG.TERMINAL_VELOCITY, CONFIG.TERMINAL_VELOCITY);
        
        // Apply velocity
        this.y += this.vy * dt;

        // Rotation based on velocity for visual flair
        const targetRot = (this.vy / CONFIG.TERMINAL_VELOCITY) * (Math.PI / 4);
        this.rotation = Utils.lerp(this.rotation, targetRot, dt * 10);
    }

    getBounds() {
        return {
            left: this.x - this.width/2,
            right: this.x + this.width/2,
            top: this.y - this.height/2,
            bottom: this.y + this.height/2
        };
    }

    draw(ctx) {
        if (this.isDead) return;

        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        
        // Glow
        ctx.shadowBlur = 20;
        ctx.shadowColor = CONFIG.PLAYER_GLOW;
        ctx.fillStyle = CONFIG.PLAYER_COLOR;
        
        // Draw Main Body (Square with slightly rounded feel via rendering trick or just rect)
        ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
        
        // Inner core
        ctx.fillStyle = '#fff';
        ctx.shadowBlur = 0;
        ctx.fillRect(-this.width/4, -this.height/4, this.width/2, this.height/2);

        ctx.restore();
    }
}

class ObstacleManager {
    constructor() {
        this.obstacles = [];
        this.timer = 0;
        this.passedCount = 0;
    }

    reset() {
        this.obstacles = [];
        this.timer = 0;
        this.passedCount = 0;
    }

    update(dt, gameSpeed, canvasWidth, canvasHeight) {
        // Spawn logic
        // We spawn based on distance moved (time * speed) or just simple timer
        // Let's use distance approximation
        const spawnInterval = CONFIG.SPAWN_DISTANCE / gameSpeed;
        
        this.timer += dt;
        if (this.timer >= spawnInterval) {
            this.spawn(canvasWidth, canvasHeight, gameSpeed);
            this.timer = 0;
        }

        // Move and Cull
        for (let i = this.obstacles.length - 1; i >= 0; i--) {
            const obs = this.obstacles[i];
            obs.x -= gameSpeed * dt;

            // Remove if off screen
            if (obs.x + obs.width < 0) {
                this.obstacles.splice(i, 1);
            }
        }
    }

    spawn(x, h, speed) {
        // Calculate difficulty factor (0.0 to 1.0)
        // Cap speed at max, so difficulty is ratio of current speed vs max
        const difficulty = Math.min(1.0, (speed - CONFIG.FORWARD_SPEED_BASE) / (CONFIG.FORWARD_SPEED_MAX - CONFIG.FORWARD_SPEED_BASE));
        
        const gap = Utils.lerp(CONFIG.GAP_SIZE_BASE, CONFIG.GAP_SIZE_MIN, difficulty);
        const minMargin = 50; // Minimum solid wall height
        const availableHeight = h - gap - (minMargin * 2);
        
        const randomOffset = Math.random() * availableHeight;
        const gapTopY = minMargin + randomOffset;
        const gapBottomY = gapTopY + gap;

        // Add pair of rectangles (Top and Bottom)
        this.obstacles.push({
            x: x,
            width: CONFIG.OBSTACLE_WIDTH,
            type: 'top',
            top: 0,
            bottom: gapTopY,
            passed: false
        });

        this.obstacles.push({
            x: x,
            width: CONFIG.OBSTACLE_WIDTH,
            type: 'bottom',
            top: gapBottomY,
            bottom: h,
            passed: false
        });
    }

    draw(ctx) {
        ctx.fillStyle = '#222';
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;

        for (const obs of this.obstacles) {
            ctx.beginPath();
            ctx.rect(obs.x, obs.top, obs.width, obs.bottom - obs.top);
            
            // Subtle gradient
            const grad = ctx.createLinearGradient(obs.x, obs.top, obs.x + obs.width, obs.top);
            grad.addColorStop(0, '#1c1c24');
            grad.addColorStop(1, '#2a2a35');
            ctx.fillStyle = grad;
            
            ctx.fill();
            ctx.stroke();

            // Tech detail line
            ctx.beginPath();
            ctx.strokeStyle = '#45a29e';
            ctx.globalAlpha = 0.3;
            if (obs.type === 'top') {
                ctx.moveTo(obs.x, obs.bottom - 5);
                ctx.lineTo(obs.x + obs.width, obs.bottom - 5);
            } else {
                ctx.moveTo(obs.x, obs.top + 5);
                ctx.lineTo(obs.x + obs.width, obs.top + 5);
            }
            ctx.stroke();
            ctx.globalAlpha = 1.0;
        }
    }

    checkCollisions(player, audio) {
        const pBounds = player.getBounds();
        let hit = false;
        let scoreIncrement = 0;

        // Group obstacles by X to check for "passing" logic
        // We only increment score once per vertical slice passed
        
        for (const obs of this.obstacles) {
            // Collision
            const obsBounds = {
                left: obs.x,
                right: obs.x + obs.width,
                top: obs.top,
                bottom: obs.bottom
            };

            if (Utils.rectIntersect(pBounds, obsBounds)) {
                hit = true;
            }

            // Scoring
            if (!obs.passed && player.x > obs.x + obs.width) {
                obs.passed = true;
                // Only count the top one to avoid double score
                if (obs.type === 'top') {
                    scoreIncrement++;
                    audio.playScore();
                }
            }
        }
        
        return { hit, scoreIncrement };
    }
}

/* ==========================================================================
   6. GAME ENGINE
   The central brain connecting everything.
   ========================================================================== */
class Game {
    constructor() {
        this.canvas = document.getElementById('stage');
        this.ctx = this.canvas.getContext('2d', { alpha: false }); // Optimize
        
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        
        this.audio = new AudioController();
        this.particles = new ParticleSystem();
        this.player = new Player(this.width * 0.2, this.height * 0.5);
        this.obstacles = new ObstacleManager();
        
        this.state = 'MENU'; // MENU, PLAYING, GAMEOVER
        this.lastTime = 0;
        this.score = 0;
        this.highScore = 0;
        this.gameSpeed = CONFIG.FORWARD_SPEED_BASE;
        this.distance = 0;

        // Shake effect
        this.shakeTime = 0;
        this.shakeMag = 0;

        // Bind Resize
        window.addEventListener('resize', () => this.resize());
        this.resize();

        // Bind Input
        this.setupInput();

        // Start Loop
        requestAnimationFrame((t) => this.loop(t));
    }

    resize() {
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.canvas.width = this.width;
        this.canvas.height = this.height;
        
        // Keep player relative if in menu
        if (this.state === 'MENU') {
            this.player.y = this.height * 0.5;
            this.player.x = this.width * 0.2;
            this.player.startY = this.height * 0.5;
            this.player.startX = this.width * 0.2;
        }
    }

    setupInput() {
        const trigger = (e) => {
            // Prevent default zooming or scrolling on touch
            if (e.type === 'touchstart' || e.code === 'Space') {
                e.preventDefault();
            }
            this.handleInput();
        };

        window.addEventListener('mousedown', trigger);
        window.addEventListener('touchstart', trigger, {passive: false});
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') trigger(e);
        });
    }

    handleInput() {
        // Init audio on first interaction
        this.audio.init();

        if (this.state === 'MENU' || this.state === 'GAMEOVER') {
            this.resetGame();
            this.state = 'PLAYING';
            this.updateUI();
        } else if (this.state === 'PLAYING') {
            this.player.flip();
            this.audio.playFlip(this.player.gravityDir);
        }
    }

    resetGame() {
        this.player.reset();
        this.obstacles.reset();
        this.particles.clear();
        this.score = 0;
        this.gameSpeed = CONFIG.FORWARD_SPEED_BASE;
        this.distance = 0;
        this.shakeTime = 0;
        
        // Hide UI screens
        document.getElementById('start-screen').classList.remove('visible');
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('game-over-screen').classList.remove('visible');
        document.getElementById('tutorial').classList.add('hidden');
    }

    gameOver() {
        this.state = 'GAMEOVER';
        this.player.isDead = true;
        this.audio.playCrash();
        
        // Screen Shake
        this.shakeTime = 0.5;
        this.shakeMag = 20;

        // Explosion
        this.particles.emit(this.player.x, this.player.y, CONFIG.PARTICLE_COUNT_DEATH, CONFIG.PLAYER_COLOR, 400);

        // UI
        if (this.score > this.highScore) {
            this.highScore = this.score;
            document.getElementById('high-score').textContent = this.highScore.toString().padStart(4, '0');
        }
        document.getElementById('game-over-screen').classList.add('visible');
    }

    update(dt) {
        if (this.state === 'PLAYING') {
            // Update Speed (Difficulty)
            if (this.gameSpeed < CONFIG.FORWARD_SPEED_MAX) {
                this.gameSpeed += CONFIG.SPEED_INC_PER_SEC * dt;
            }

            // Player Physics
            this.player.update(dt);

            // Bounds Check (Floor/Ceiling)
            if (this.player.y < 0 || this.player.y > this.height) {
                this.gameOver();
            }

            // Obstacles
            this.obstacles.update(dt, this.gameSpeed, this.width, this.height);

            // Collisions
            const result = this.obstacles.checkCollisions(this.player, this.audio);
            if (result.hit) {
                this.gameOver();
            }
            if (result.scoreIncrement > 0) {
                this.score += result.scoreIncrement;
                document.getElementById('score').textContent = this.score.toString().padStart(4, '0');
            }

            // Particles (Trail)
            // Emit trail periodically
            if (Math.random() < 0.5) {
                this.particles.emitTrail(this.player.x, this.player.y, CONFIG.PLAYER_COLOR);
            }
        }

        // Always update particles
        this.particles.update(dt);

        // Screen Shake decay
        if (this.shakeTime > 0) {
            this.shakeTime -= dt;
            if (this.shakeTime < 0) this.shakeTime = 0;
        }
    }

    draw() {
        // Clear background
        this.ctx.fillStyle = '#0b0c10';
        this.ctx.fillRect(0, 0, this.width, this.height);

        // Draw animated background grid
        this.drawBackground();

        // Apply Screen Shake
        this.ctx.save();
        if (this.shakeTime > 0) {
            const mag = this.shakeMag * (this.shakeTime / 0.5);
            const dx = (Math.random() - 0.5) * mag;
            const dy = (Math.random() - 0.5) * mag;
            this.ctx.translate(dx, dy);
        }

        this.obstacles.draw(this.ctx);
        this.particles.draw(this.ctx);
        this.player.draw(this.ctx);

        this.ctx.restore();
    }

    drawBackground() {
        this.ctx.strokeStyle = '#1f2833';
        this.ctx.lineWidth = 1;
        
        // Offset based on time to simulate movement
        const offset = (Date.now() / 1000 * this.gameSpeed * 0.5) % CONFIG.BG_GRID_SIZE;
        
        this.ctx.beginPath();
        // Vertical lines moving left
        for (let x = -offset; x < this.width; x += CONFIG.BG_GRID_SIZE) {
            this.ctx.moveTo(x, 0);
            this.ctx.lineTo(x, this.height);
        }
        // Horizontal lines static (or slow parallax)
        for (let y = 0; y < this.height; y += CONFIG.BG_GRID_SIZE) {
            this.ctx.moveTo(0, y);
            this.ctx.lineTo(this.width, y);
        }
        this.ctx.stroke();
    }

    updateUI() {
        // handled in logic events
    }

    loop(timestamp) {
        // Calculate Delta Time
        const dt = Math.min((timestamp - this.lastTime) / 1000, 0.1); // Cap dt at 0.1s
        this.lastTime = timestamp;

        this.update(dt);
        this.draw();

        requestAnimationFrame((t) => this.loop(t));
    }
}

// ==========================================
// INITIALIZATION
// ==========================================
window.onload = () => {
    const game = new Game();
};

</script>
</body>
</html>
